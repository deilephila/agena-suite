<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
:root {
  --main_background-color: #232323;
  --main_text-color: #bbb;
  --text_inside: black;
}

html {
    background-color: var(--main_background-color);
    color: var(--main_text-color);
}
body {
    width: 40em;
    margin: auto;
    padding: 3em 2em;
    border-left: 1px solid #bbb;
    border-right: 1px solid #bbb;
}

textarea { 
    width: 100%;
    font-size: 1.2em;
    margin-bottom: 1em;
    height: 4em;
    color: black;
}

div {
    margin: 1em;
    font-size: 1.2em;
}

#withBut {
display: flex;
align-items: center;
justify-content: center;
}

but {
width: 7em;
display: block;
display: flex;
align-items: center;
justify-content: center;
padding: 0.4em;
margin: 0.5em;
border: 4px solid black;
border-radius: 0.5em;
background: white;
font-weight: bold;
text-align: center;
color: var(--text_inside);
}

table {
    width: 100%;
}
table, td {
    border: 1px solid #444;
}

.invis, .invis2, .invis3 {
    visibility: hidden;
}

</style>

<style>
.header1 {
    font-size: 2.5em;
    display: flex;
    align-items: center;
    justify-content: center;
}

.header2 {
    font-size: 2em;
    display: flex;
    align-items: center;
    justify-content: center;
}

.hidden {
    display: none;
}

#InputSetOfUEP {
    height: 10em;
}

</style>
</head>
<body>
<div class="header1"> UEP check </div>
<div> Enter the masses of terminators (after ionization): </div>
<div>
    <input name="r2" type="radio" value="" checked="checked"> iPlex
    <input name="r2" type="radio" value=""> ddNTP 
    <input name="r2" type="radio" value=""> TM-3M 
    <input name="r2" type="radio" value=""> TM-1M
    <input name="r2" type="radio" value=""> TM-U 
</div>

<div> + A <input id="InputMassA" type="number" value='271.2' > </div>
<div> + T <input id="InputMassT" type="number" value='327.1'> </div>
<div> + G <input id="InputMassG" type="number" value='287.3'> </div>
<div> + C <input id="InputMassC" type="number" value='247.2'> </div>

<div class="header2"> Check the mass </div>
<textarea type='text' placeholder="tgactAGACCTGAGCCTCTTC" id='InputCheckMass'></textarea>
<table id="outputCheckMass"></table>


<div class="header2"> Check the set of UEP </div>
<div class = "hidden">
<input name="r1" type="radio" value="" checked="checked"> UEP sequence
<input name="r1" type="radio" value=""> UEP mass
</div>
<textarea type='text' id='InputSetOfUEP' placeholder="UEP1	agTACAGGCTGCCTCAGC	F	C/T"></textarea>
<input type="file" id="inputFile">

<div id="outputStatus"></div>
<table id="outputSetOfUEP"></table>
<table id="outputAssayDesign"></table>
<div class="invis3" id='withBut'><but id="buttonDownload">Download Assay</but></div>

<div class="invis2" id='withBut'><but id="buttonAddUEP">Add UEP</but></div>
<div class="invis"> 
    <textarea type='text' id='amp_oligoToAdd'></textarea>
    <div> Direction:
    <input name="r3" type="radio" value="" checked="checked"> Forward
    <input name="r3" type="radio" value=""> Reverse </div>
    <label for="choiceSNP">
        <input type="checkbox" name = "choiceSNP" value="A">  A
        <input type="checkbox" name = "choiceSNP" value="C">  C
        <input type="checkbox" name = "choiceSNP" value="T">  T
        <input type="checkbox" name = "choiceSNP" value="G">  G
     </label>
     <div id='withBut'><but id="addOligo">Add</but></div>
</div>

<script>

let finalOutput = [];
let fromFile = [];

const inputFile = document.getElementById("inputFile");
function handleFile(file) {
  //console.log("file:", file);
    let reader = new FileReader();
    reader.onload = () => {finalOutput = regexSearch(reader.result)};
    reader.readAsText(file);
}

function regexSearch(text) {
        const regex = /W\d[^W]*/g
        const matched = [... text.matchAll(regex)];
        fromFile = matched;
        let arrayOfObjects = renderResult(matched);
        return arrayOfObjects
    }

function makeAllele (oneRS) {
    let array = [];
    for (let i = 14; i<25; i += 3) {
        let ntpToAdd = oneRS[i+2].split("").at(-1);
        let snp = oneRS[11] == "F" ? ntpToAdd : cN[ntpToAdd];
        let obj = {
            allele: oneRS[i],
            EPmass: oneRS[i+1],
            EPseq: oneRS[i+2]
        }
        array.push(obj)
    }
    return array
}

function renderResult(res){
    let arrOfObjFromFile = [];
    for (let i=0; i<res.length; i++) {
        let oneRS = res[i][0];
        oneRS = oneRS.split("\t");
        let objFromFile = {
            name: oneRS[2],
            dir: oneRS[11],
            UEPmass: oneRS[12],
            seq: oneRS[13],
            EP: makeAllele(oneRS)
        }
        console.log(objFromFile)
        let snp = [];
        objFromFile.EP.forEach((e)=> {
            e.allele && snp.push(e.allele)
        }); 
        objFromFile.snp = snp;    
        arrOfObjFromFile.push(objFromFile);
    }
    console.log(arrOfObjFromFile);
    let arrayOfObjects = fromXLStoInput (arrOfObjFromFile);
    return arrayOfObjects;
}

function fromXLStoInput (arrOfObjFromFile) {
    let arrayOfObjects = [];
    arrOfObjFromFile.forEach((rs) => {
        let objectOfUEP = {
            name: rs.name,
            seq: rs.seq.toUpperCase(),
            dir: rs.dir,
            snp: rs.snp,
            UEPmass: calculateUEPMass(rs.seq.toUpperCase()),
        }
        objectOfUEP.EP = calculateEPMass(objectOfUEP);
        arrayOfObjects.push(objectOfUEP);
    })
    console.log(arrayOfObjects);
    
    let arrayConflicts = massCompare(arrayOfObjects);
    CheckSetOutputStatus(arrayConflicts);
    CheckSetOutputTable (arrayOfObjects);
    return arrayOfObjects
}

//функция для определения выбранного radio button - универсальная! на вход - name radio button ("r1")
function radioButton(name) {
    let rad=document.getElementsByName(name);
    let output;
    for (let i=0; i<rad.length; i++) {
        if (rad[i].checked) {
            output = i;
        }
    }
    return output
}

// изменение value внутри инпута для массы каждой буквы в зависимости от выбранного ТМ (radio button)
function chooseTM() {
    let outputFromR2 = radioButton("r2");
    let TMiPlex = {
        'A': 271.2,
        'T': 327.1,
        'G': 287.3,
        'C': 247.2
    }
    let TMddNTP = {
        'A': 296.2,
        'T': 287.1,
        'G': 312.3,
        'C': 272.2
    }
    let TM3M = {
        'A': 601.4,
        'T': 287.1,
        'G': 618,
        'C': 578.5
    }
    let TM1M = {
        'A': 296.2,
        'T': 577.8,
        'G': 312.3,
        'C': 272.2
    }
    let TMU = {
        'A': 296.2,
        'T': 441,
        'G': 312.3,
        'C': 272.2
    }


    let arrayOfTM = [TMiPlex, TMddNTP, TM3M, TM1M, TMU];
    document.getElementById("InputMassA").value = arrayOfTM[outputFromR2]['A'];
    document.getElementById("InputMassT").value = arrayOfTM[outputFromR2]['T'];
    document.getElementById("InputMassC").value = arrayOfTM[outputFromR2]['C'];
    document.getElementById("InputMassG").value = arrayOfTM[outputFromR2]['G'];

    document.getElementById("InputCheckMass").dispatchEvent(new Event("input"));
    document.getElementById("InputSetOfUEP").dispatchEvent(new Event("input"));
}


// функция для записи значений масс терминаторов (введеных пользователем), output - array
function inputTerminationMass () {
    let termMasses = {};
    termMasses["A"] = parseFloat(document.getElementById('InputMassA').value.replace(',', '.'));
    termMasses["T"] = parseFloat(document.getElementById('InputMassT').value.replace(',', '.'));
    termMasses["C"] = parseFloat(document.getElementById('InputMassC').value.replace(',', '.'));
    termMasses["G"] = parseFloat(document.getElementById('InputMassG').value.replace(',', '.'));
    return (termMasses);
}

//функция расчета массы UEP
function calculateUEPMass(UEPsequence) {
    let A = 0; let G = 0; let C = 0; let T = 0;
    let seq = UEPsequence;
    let UEPLength = seq.length;
    for (i in seq) {
        if (seq[i] == 'A') {A += 1;}
        else if (seq[i] == 'G') {G += 1;}
        else if (seq[i] == 'C') {C += 1;}
        else if (seq[i] == 'T') {T += 1;}
        else {throw new Error("invalid character in sequence")}}
    let UEPmass = Number((249.2*A + 225.2*C + 265.2*G + 240.2*T + 64*(UEPLength - 1) + 2.95).toFixed(1));
    return (UEPmass)};

let cN = {
    'C': 'G',
    'A': 'T',
    'G': 'C',
    'T': 'A',
}

//функция расчета массы EP
function calculateEPMass (objectOfUEP) {
    let terminationMasses = inputTerminationMass();
    let mass = objectOfUEP.UEPmass;
    let snp = objectOfUEP.snp; // на вход - ["C", "T"] - надо!
    let dir = objectOfUEP.dir; // на вход - 'F', формат string
    let seq = objectOfUEP.seq;
    let arrayOfObjForEP = [];
    

    for (i in snp) {
        let termNTP = dir == 'F' ? snp[i] : cN[snp[i]];

        let EPobj = {
            allele: snp[i],
            EPmass: Math.round((mass + terminationMasses[termNTP])*10)/10,
            EPseq: seq + termNTP
        };
        arrayOfObjForEP[i] = EPobj;
     }
    return (arrayOfObjForEP)
 }

//функция формирования объектов с данными по каждому UEP
function checkSet(text) {
    if (!text) return;
    let outputFromR1 = radioButton("r1");
    let strings = text.trim().split("\n").toString().split(",");
    let arrayOfObjects = [];
    
    strings.forEach(str => {
        str = str.split("	");
        let objectOfUEP = {
            name: str[0],
            seq: outputFromR1 == 0
                ? str[1].toString()
                : undefined,
            dir: str[2],
            snp: str[3].split("/"),
            UEPmass: outputFromR1 == 0
                ? calculateUEPMass(str[1].toString().toUpperCase())
                : str[1],
        }
        objectOfUEP.EP = calculateEPMass(objectOfUEP);
        arrayOfObjects.push(objectOfUEP);
    })
    let arrayConflicts = massCompare(arrayOfObjects);
    CheckSetOutputStatus(arrayConflicts);
    CheckSetOutputTable (arrayOfObjects);
    finalOutput =  arrayOfObjects;
    return arrayOfObjects
}

function massCompare(arrayOfObjects) {
    let arrayOfMasses = [];
    arrayOfObjects.forEach((oneUEP) => {
        let nameUEP = oneUEP.name
        let objUEP = {
            name: nameUEP,
            mass: oneUEP.UEPmass
        };
        arrayOfMasses.push(objUEP);
        oneUEP.EP.forEach((allele) => {
            let objEP = {
            name: nameUEP,
            mass: allele.EPmass
        }
        arrayOfMasses.push(objEP);
        })
    })
    let arrayConflicts = [];
    for (let i=0; i < arrayOfMasses.length; i++) {
        let mass1 = arrayOfMasses[i].mass;
        let name1 = arrayOfMasses[i].name;
        for (let k = i + 1; k < arrayOfMasses.length; k++) {
            if (arrayOfMasses[k].name != name1) {
                let mass2 = arrayOfMasses[k].mass;
                let delta = mass2 - mass1;
                if (delta < 30 && delta > -30) {
                    arrayConflicts.push([arrayOfMasses[i], arrayOfMasses[k]]);
                }}}}
    let names = [];
    arrayConflicts.forEach((array) => {
        let str = [array[0].name, "/*!/", array[1].name].join("");
        names.push(str);
    });
    uniqueArray = names.filter(function(item, pos) {
        return names.indexOf(item) == pos;
    })
    let uniqueArrayFinal = [];
    uniqueArray.forEach((conflict) => {
        uniqueArrayFinal.push(conflict.split("/*!/"))
    })
    return (uniqueArrayFinal)
}

function CheckSetOutputStatus (uniqueArrayFinal) {
    let html = "";
    if (uniqueArrayFinal.length == 0) {
        html = "Great UEPs!";
        makeVisible("invis2")
    } else {
        uniqueArrayFinal.forEach((conflict) => {
            html += `<div> Attention! ${conflict[0]} has conflict with ${conflict[1]}! </div>`;
        })
    }
    document.getElementById("outputStatus").innerHTML = html;
}

function CheckSetOutputTable (arrayOfObjects) {
    let html = `<tr>
        <th>Name</th>
        <th>Sequence</th>
        <th>Direction</th>
        <th>SNP</th>
        <th>UEP mass</th>
        </tr>`
    arrayOfObjects.forEach((array) => {
        let snp = array.snp.join("/");
        html += `<tr>
                    <td>${array.name}</td>
                    <td>${array.seq}</td>
                    <td>${array.dir}</td>
                    <td>${snp}</td>
                    <td>${array.UEPmass}</td>
                </tr>`;
    })
    document.getElementById("outputSetOfUEP").innerHTML = html;
    makeVisible("invis3")
}

function CheckMassOutputTable (arrayOfObjects) {
    let html = `<tr>
        <th>Sequence</th>
        <th>UEP mass</th>
        <th>+A</th>
        <th>+T</th>
        <th>+C</th>
        <th>+G</th>
        </tr>`
    arrayOfObjects.forEach((array) => {
        html += `<tr>
            <td>${array.seq}</td>
            <td>${array.UEPmass}</td>
            <td>${array.EP[0].EPmass}</td>
            <td>${array.EP[1].EPmass}</td>
            <td>${array.EP[2].EPmass}</td>
            <td>${array.EP[3].EPmass}</td>
            </tr>`;
    })
    document.getElementById("outputCheckMass").innerHTML = html;
}

function checkMass (text) {
    if (!text) return;
    let strings = text.trim().split("\n").toString().split(",");
    let arrayOfObjects = [];
    strings.forEach(str => {
        let objectOfUEP = {
            seq: str.toString(),
            UEPmass: calculateUEPMass(str.toString().toUpperCase()),
            dir: "F",
            snp: ["A", "T", "C", "G"]
        }
        objectOfUEP.EP = calculateEPMass(objectOfUEP);
        arrayOfObjects.push(objectOfUEP);
    })
    console.log(arrayOfObjects);
    CheckMassOutputTable(arrayOfObjects);
}

document.getElementById("InputCheckMass").addEventListener("input", () => checkMass(document.getElementById("InputCheckMass").value));
document.getElementById("InputSetOfUEP").addEventListener("input", () => checkSet(document.getElementById("InputSetOfUEP").value));
document.getElementsByName('r1').forEach( r =>
    r.addEventListener("input", () => checkSet(document.getElementById("InputSetOfUEP").value))
)
inputFile.addEventListener("change",(e)=>handleFile(e.target.files[0]));

/* при переключении ТМ (radio button) изменяются value внутри инпутов масс букв*/
document.getElementsByName('r2').forEach( r =>
    r.addEventListener("change", () => chooseTM()));

document.getElementById("buttonDownload").addEventListener("click", Download)

function ConvertToCSV(objArray) {
  let array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;
  let str = '';
  for (let i = 0; i < array.length; i++) {
    var line = '';
    for (var index in array[i]) {
      if (line != '') {
        line += ','
        }
      line += array[i][index];
    }
    str += line + '\r\n';
  }
  return str;
}



function makeJSON (finalOutput, fromFile) {
    let json = [];
    let firstString = {
        "WELL": "WELL", "TERM": "TERM", "SNP_ID": "SNP_ID",
        "2nd-PCRP": "2nd-PCRP", "1st-PCRP": "1st-PCRP", "AMP_LEN": "AMP_LEN",
        "UP_CONF": "UP_CONF", "MP_CONF": "MP_CONF", "Tm(NN)": "Tm(NN)",
        "PcGC": "PcGC", "PWARN": "PWARN", "UEP_DIR": "UEP_DIR", "UEP_MASS": "UEP_MASS", 
        "UEP_SEQ": "UEP_SEQ", "EXT1_CALL": "EXT1_CALL", "EXT1_MASS": "EXT1_MASS",
        "EXT1_SEQ": "EXT1_SEQ", "EXT2_CALL": "EXT2_CALL", "EXT2_MASS": "EXT2_MASS",
        "EXT2_SEQ": "EXT2_SEQ", "EXT3_CALL": "EXT3_CALL", "EXT3_MASS": "EXT3_MASS",
        "EXT3_SEQ": "EXT3_SEQ", "EXT4_CALL": "EXT4_CALL", "EXT4_MASS": "EXT4_MASS",
        "EXT4_SEQ": "EXT4_SEQ", "1stPAUSE": "1stPAUSE"
    };
    json.push(firstString);
    if (fromFile[0] == undefined) {
        console.log(fromFile[0] == undefined)
        finalOutput.forEach((oneRS) => {
            let string = {
            "WELL": " ", "TERM": "iPlex", "SNP_ID": oneRS.name,
            "2nd-PCRP": " ", "1st-PCRP": " ", "AMP_LEN": " ",
            "UP_CONF": " ", "MP_CONF": " ", "Tm(NN)": " ",
            "PcGC": " ", "PWARN": " ", "UEP_DIR": oneRS.dir, "UEP_MASS": oneRS.UEPmass, 
            "UEP_SEQ": oneRS.seq,
            "EXT1_CALL": oneRS.EP[0].allele, "EXT1_MASS": oneRS.EP[0].EPmass, "EXT1_SEQ": oneRS.EP[0].EPseq,
            "EXT2_CALL": oneRS.EP[1] == undefined ? "" : oneRS.EP[1].allele, "EXT2_MASS": oneRS.EP[1] == undefined ? "" : oneRS.EP[1].EPmass, "EXT2_SEQ": oneRS.EP[1] == undefined ? "" : oneRS.EP[1].EPseq,
            "EXT3_CALL": oneRS.EP[2] == undefined ? "" : oneRS.EP[2].allele, "EXT3_MASS": oneRS.EP[2] == undefined ? "" : oneRS.EP[2].EPmass, "EXT3_SEQ": oneRS.EP[2] == undefined ? "" : oneRS.EP[2].EPseq,
            "EXT4_CALL": oneRS.EP[3] == undefined ? "" : oneRS.EP[3].allele, "EXT4_MASS": oneRS.EP[3] == undefined ? "" : oneRS.EP[3].EPmass, "EXT4_SEQ": oneRS.EP[3] == undefined ? "" : oneRS.EP[3].EPseq,
            "1stPAUSE": " "};
            json.push(string);
        })
        console.log(json);
    } else {
        for (let i=0; i<fromFile.length; i++) {
            let oneRS = fromFile[i][0];
            oneRS = oneRS.split("\t");
            console.log(oneRS);
            let string = {
                "WELL": oneRS[0], "TERM": oneRS[1], "SNP_ID": oneRS[2],
                "2nd-PCRP": oneRS[3], "1st-PCRP": oneRS[4], "AMP_LEN": oneRS[5],
                "UP_CONF": oneRS[6], "MP_CONF": oneRS[7], "Tm(NN)": oneRS[8],
                "PcGC": oneRS[9], "PWARN": oneRS[10], "UEP_DIR": oneRS[11], "UEP_MASS": finalOutput[i].UEPmass, 
                "UEP_SEQ": oneRS[13], "EXT1_CALL": oneRS[14], "EXT1_MASS": finalOutput[i].EP[0].EPmass,
                "EXT1_SEQ": oneRS[16], "EXT2_CALL": oneRS[17], "EXT2_MASS": finalOutput[i].EP[1].EPmass,
                "EXT2_SEQ": oneRS[19], "EXT3_CALL": oneRS[20], "EXT3_MASS": finalOutput[i].EP[2] == undefined ? "" : finalOutput[i].EP[2].EPmass,
                "EXT3_SEQ": oneRS[22], "EXT4_CALL": oneRS[23], "EXT4_MASS": finalOutput[i].EP[3] == undefined ? "" : finalOutput[i].EP[3].EPmass,
                "EXT4_SEQ": oneRS[25], "1stPAUSE": " ",}
            json.push(string);
        }
    }
    return json
}

function Download() {
    let json = fromFile[0] == undefined ? finalOutput : fromFile;
    let newjson = makeJSON (finalOutput, fromFile);
    let csv = ConvertToCSV(newjson);
    let downloadLink = document.createElement("a");
    let blob = new Blob(["\ufeff", csv]);
    let url = URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = "data.csv";

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
};


document.getElementById("buttonAddUEP").addEventListener("click", () => makeVisible("invis"));
function makeVisible(className) {
    document.getElementsByClassName(className)[0].style= "visibility: visible";
}

document.getElementById("addOligo").addEventListener("click", () => addUEP());

// функция по добавлению UEP в существующий assay
function addUEP () {
    let snp = checkboxSNP();
    console.log(snp);
    let ampseq = document.getElementById("amp_oligoToAdd").value;
    console.log("full amp: " + ampseq)
    let dir = radioButton("r3")==0 ? "F" : "R";
    let UEPmax = cutAmp(ampseq);
    let suitableUEP = chooseUEP(UEPmax, dir, snp)
    //сюда написать функцию для формирования аутпута
}

// модуль addUEP, подбор подходящих вариантов UEP, запуск из addUEP
function chooseUEP(UEPmax, dir, snp) {
    let suitableUEP = [];
    let UEPseqVar = UEPmax;
    let UEPmassVar = calculateUEPMass(UEPseqVar);
    while (UEPmassVar > 4300) {
        //создаем для каждого UEP object
        let newUEP = {
            name: "new",
            seq: UEPseqVar,
            dir: dir,
            snp: snp,
            UEPmass: UEPmassVar
        }
        newUEP.EP = calculateEPMass(newUEP);
        //берем актуальный arrayOfObjects (текущий набор праймеров, загруженный пользователем)
        let arrayOfObjects = checkSet(document.getElementById("InputSetOfUEP").value);
        //исключаем UEP, у которых масса EP > 9000 (добавляем в arrayOfObject только те UEP, EP которых < 9000)
        //и тут же проверяем обновленный arrayOfObjects на конфликты, если их нет, то новый UEP пушится в suitableUEP
        let lessThan9000 = 0;
        newUEP.EP.forEach((i)=> {
            if (i.EPmass > 9000) {
                lessThan9000 += 1;
            }
        })
        if (lessThan9000 == 0) {
            arrayOfObjects.push(newUEP);
            if (massCompare(arrayOfObjects).length == 0) {
                suitableUEP.push(newUEP);
            }
        }
        //убираем первую букву UEPseqVar, чтобы в следующем цикле прогонять новую посл-ть 
        UEPseqVar = UEPseqVar.slice(1);
        UEPmassVar = calculateUEPMass(UEPseqVar)
    }
    console.log(suitableUEP);
    return suitableUEP
}

// функция по подсчету массы ампликона для модуля Add UEP
function cutAmp(ampseq) {
    let maxMass = 0; //масса олига (конечная) на каждом цикле (+64*(length...))
    let UEPmax = ""; //последовательность олига, растет на каждом цикле
    let UEPmassCount = 0; //масса олига неконечная (!), масса только букв (без +64...), нужна для счета
    for (let i=ampseq.length-1; i>=0; i--) {
        if (maxMass > 9000) break
        if (ampseq[i] == 'A') {
            maxMass = Number((Number(UEPmassCount)+249.2 + 64*(UEPmax.length - 1) + 2.95).toFixed(1));
            UEPmassCount += 249.2;
            UEPmax += "A";
        } else if (ampseq[i] == 'G') {
            maxMass = Number((Number(UEPmassCount)+265.2 + 64*(UEPmax.length - 1) + 2.95).toFixed(1));
            UEPmassCount += 265.2;
            UEPmax += "G";
        } else if (ampseq[i] == 'C') {
            maxMass =Number((Number(UEPmassCount)+225.2 + 64*(UEPmax.length - 1) + 2.95).toFixed(1));
            UEPmassCount += 225.2;
            UEPmax += "C";
        } else if (ampseq[i] == 'T') {
            maxMass = Number((Number(UEPmassCount)+240.2 + 64*(UEPmax.length - 1) + 2.95).toFixed(1));
            UEPmassCount += 240.2;
            UEPmax += "T";
        } else {throw new Error("invalid character in sequence")}
    }
    //мы получили reverse amp, надо его перевернуть и убрать первую букву
    UEPmax = UEPmax.slice(0,-1).split("").reverse().join("");
    return UEPmax
};

//функция для записи выбранных SNP для модуля Add UEP
function checkboxSNP() {
    let check=document.getElementsByName('choiceSNP');
    let output = [];
    for (let i=0; i<check.length; i++) {
        if (check[i].checked) {
            output.push(check[i].value);
        }
    }
    return output
};
</script>

</body>
</html>
